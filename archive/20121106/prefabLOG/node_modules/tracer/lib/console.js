var tinytim = require('tinytim'), dateFormat = require('dateformat'), utils = require('./utils')
//var prefab = require('../../../../prefab')();
var debug = require('/home/jochen/dev/code/git/prefab/prefab/node_modules/debug')('console');
module.exports = (function() {
	// default config
	var _config = {
		format : "{{timestamp}} <{{title}}> {{file}}:{{line}} ({{method}}) {{message}}",
		dateformat : "UTC:yyyy-mm-dd'T'HH:MM:ss.l'Z'",
		preprocess : function(data) {
		},
		transport : function(data) {
			//console.log(data.output);
//			console.error.apply(this, arguments);
			process.stdout.write(data.output + '\n');
		},
		filters : [],
		level : 'log',
		methods : [ 'log', 'trace', 'debug', 'info', 'warn', 'error' ]
	};
	
	debug('booting with _config: %j', _config);

	// union user's config and default
	_config = utils.union(_config, arguments);
	debug('booting with _config.filters: %j', _config.filters);

	// main log method
	var _log = function(level, title, format, filters, needstack, args) {
//		debug("_log arguments",arguments);
		debug("_log needstack",needstack);
		var data = {
			timestamp : dateFormat(new Date(), _config.dateformat),
			message : "",
			title : title,
			level : level,
			args : args
		};
		data.method = data.path = data.line = data.pos = data.file = '';

		if (needstack) {
			// get call stack, and analyze it
			// get all file,method and line number
			data.stack = (new Error()).stack.split('\n').slice(3);
			debug("_log data.stack: %j",data.stack);

			var stackBeginIndex = 1;
			
			// Stack trace format :
			// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
			var s = data.stack[stackBeginIndex],
				sp = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/gi.exec(s)
					|| /at\s+()(.*):(\d*):(\d*)/gi.exec(s);
					
			debug("_log sp",sp);
					
					
			if (sp && sp.length === 5) {
				data.method = sp[1];
				data.path = sp[2];
				data.line = sp[3];
				data.pos = sp[4];
				var paths = data.path.split('/');
				data.file = paths[paths.length - 1];
			}
		}
		_config.preprocess(data);
		debug("_log config.preprocess: %j",data);
		var msg = utils.format.apply(this, data.args);
		data.message = msg;

		// call micro-template to ouput
		data.output = tinytim.tim(format, data);

		// process every filter method
		var len = filters.length;
		for ( var i = 0; i < len; i += 1) {
			data.output = filters[i](data.output, data);
			if (!data.output)
				return data;
			// cancel next process if return a false(include null, undefined)
		}
		// trans the final result
		return _config.transport(data);
	};

	var _self = {};

	_config.format = Array.isArray(_config.format) ? _config.format
			: [ _config.format ];

	_config.filters = Array.isArray(_config.filters) ? _config.filters
			: [ _config.filters ];

	var len = _config.methods.length, fLen = _config.filters.length, lastFilter;
	
	debug('_config.methods: %j _config.filters: %j',_config.methods,_config.filters);
	debug('len: %s fLen: %s',len,fLen);
	
	if (fLen > 0)
		if (Object.prototype.toString.call(_config.filters[fLen - 1]) != '[object Function]') {
			fLen -= 1;
			lastFilter = _config.filters[fLen];
			_config.filters = _config.filters.slice(0, fLen);
		}

	if (typeof (_config.level) == 'string')
		_config.level = _config.methods.indexOf(_config.level);

	for ( var i = 0; i < len; ++i) {
		var title = _config.methods[i];
		if (i < _config.level)
			_self[title] = (function() {
			});// empty function
		else {
			debug('title: %j', title);
			var format = _config.format[0];
			debug("_log format",format);
			if (_config.format.length === 2 && _config.format[1][title])
				format = _config.format[1][title];
			var needstack = false;
			if (/{{(method|path|line|pos|file)}}/gi.test(format))
				needstack = true;

			var filters;
			if (lastFilter && lastFilter[title])
				filters = Array.isArray(lastFilter[title]) ? lastFilter[title]
						: [ lastFilter[title] ];
			else
				filters = _config.filters;

			debug('title: %s filters: %j', title, filters);
			
			_self[title] = (function(level, title, format, filters, needstack) {
				return (function() {
					return _log(level, title, format, filters, needstack,
							arguments);
				});

			})(i, title, format, filters, needstack);
		}
	}

	return _self;
});